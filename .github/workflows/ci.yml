name: CI

on:
  workflow_dispatch: {}
  push:
    branches: [main, master]
    paths-ignore:
      - ".github/*.yml"
      - ".github/*.yaml"
      - ".github/**/*.yml"
      - ".github/**/*.yaml"
      - "**/*.md"
  pull_request:
    branches: [main, master]
    paths-ignore:
      - ".github/*.yml"
      - ".github/*.yaml"
      - ".github/**/*.yml"
      - ".github/**/*.yaml"
      - "**/*.md"

jobs:
  build-test:
    needs: [format-check, clang-tidy, cppcheck, scan-build, semgrep]
    name: ${{ matrix.os }} • preset=${{ matrix.preset }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        preset: [dev-debug, dev-release, notones-debug]
    steps:
      - uses: actions/checkout@v6.0.2
      - name: Configure (${{ matrix.preset }})
        run: cmake --preset ${{ matrix.preset }}
      - name: Build (${{ matrix.preset }})
        run: cmake --build --preset ${{ matrix.preset }} --parallel
      - name: Test (${{ matrix.preset }})
        run: ctest --preset ${{ matrix.preset }} -V

  sanitize-linux:
    needs: [format-check, clang-tidy, cppcheck, scan-build, semgrep]
    name: linux • Debug • sanitizers
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6.0.2
      - name: Configure (asan-ubsan-debug)
        run: cmake --preset asan-ubsan-debug
      - name: Build (asan-ubsan-debug)
        run: cmake --build --preset asan-ubsan-debug --parallel
      - name: Test (asan-ubsan-debug)
        env:
          ASAN_OPTIONS: detect_leaks=1:halt_on_error=1
          UBSAN_OPTIONS: print_stacktrace=1:halt_on_error=1
        run: ctest --preset asan-ubsan-debug -V

  format-check:
    name: clang-format
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6.0.2
      - name: Install clang-format
        run: sudo apt-get update && sudo apt-get install -y clang-format
      - name: Check formatting
        run: |
          files=$(git ls-files '*.c' '*.cc' '*.cxx' '*.cpp' '*.h' '*.hpp' ':!:build/**' ':!:src/external/**')
          if [ -z "$files" ]; then echo "No C/C++ files to check"; exit 0; fi
          clang-format --version
          # Prefer dry-run Werror if supported; fallback to diff
          if clang-format -n --Werror $files 2>/dev/null; then
            echo "Formatting OK (clang-format -n --Werror)"
          else
            echo "clang-format -n --Werror unsupported or failed; using diff"
            diff -u <(cat $files) <(clang-format $files) || (echo "Run tools/format.sh" && exit 1)
          fi

  clang-tidy:
    name: clang-tidy
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6.0.2
      - name: Install toolchains
        run: |
          sudo apt-get update
          sudo apt-get install -y clang-tidy ripgrep iwyu build-essential cmake ninja-build pkg-config git ccache
      - name: Prepare ccache environment
        run: |
          set -euxo pipefail
          echo "CCACHE_DIR=${GITHUB_WORKSPACE}/.ccache" >> "$GITHUB_ENV"
          echo "CC=ccache gcc" >> "$GITHUB_ENV"
          echo "CXX=ccache g++" >> "$GITHUB_ENV"
          echo "CCACHE_BASEDIR=${GITHUB_WORKSPACE}" >> "$GITHUB_ENV"
          echo "CCACHE_NOHASHDIR=true" >> "$GITHUB_ENV"
          echo "CCACHE_SLOPPINESS=time_macros" >> "$GITHUB_ENV"
          mkdir -p "${GITHUB_WORKSPACE}/.ccache"
      - name: Compute tool versions (for ccache key)
        id: toolver-tidy
        run: |
          set -euxo pipefail
          echo "gcc_ver=$(gcc -dumpfullversion -dumpversion || gcc --version | head -n1)" >> "$GITHUB_OUTPUT"
          echo "cmake_ver=$(cmake --version | head -n1 | awk '{print $3}')" >> "$GITHUB_OUTPUT"
      - name: Restore ccache
        uses: actions/cache@v5.0.3
        with:
          path: ${{ env.CCACHE_DIR }}
          key: ccache-${{ runner.os }}-${{ github.job }}-${{ steps.toolver-tidy.outputs.gcc_ver }}-${{ steps.toolver-tidy.outputs.cmake_ver }}-${{ github.sha }}
          restore-keys: |
            ccache-${{ runner.os }}-${{ github.job }}-${{ steps.toolver-tidy.outputs.gcc_ver }}-${{ steps.toolver-tidy.outputs.cmake_ver }}-
            ccache-${{ runner.os }}-${{ github.job }}-
            ccache-${{ runner.os }}-
      - name: Initialize ccache
        run: |
          ccache --version
          ccache --zero-stats
          ccache --set-config=max_size=500M
          ccache --set-config=compression=true
      - name: Configure (dev-debug preset)
        run: cmake --preset dev-debug
      - name: Run clang-tidy (curated)
        run: tools/clang_tidy.sh
      - name: Upload clang-tidy output
        if: always()
        uses: actions/upload-artifact@v6.0.0
        with:
          name: clang-tidy-report
          path: .clang-tidy.local.out
          include-hidden-files: true
          retention-days: 7
      - name: Run IWYU
        run: tools/iwyu.sh --strict
      - name: Upload IWYU output
        if: always()
        uses: actions/upload-artifact@v6.0.0
        with:
          name: iwyu-report
          path: .iwyu.local.out
          include-hidden-files: true
          retention-days: 7
      - name: Run GCC fanalyzer
        run: tools/gcc_fanalyzer.sh
      - name: Upload GCC fanalyzer output
        if: always()
        uses: actions/upload-artifact@v6.0.0
        with:
          name: gcc-fanalyzer-report
          path: .gcc-fanalyzer.local.out
          include-hidden-files: true
          retention-days: 7
      - name: Show ccache stats
        if: always()
        run: ccache -s

  cppcheck:
    name: cppcheck
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v6.0.2

      - name: Install cppcheck
        run: |
          sudo apt-get update
          sudo apt-get install -y cppcheck

      - name: Run cppcheck
        run: |
          tools/cppcheck.sh
      - name: Upload cppcheck output
        if: always()
        uses: actions/upload-artifact@v6.0.0
        with:
          name: cppcheck-report
          path: .cppcheck.local.out
          include-hidden-files: true
          retention-days: 7

  scan-build:
    name: scan-build
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v6.0.2
      - name: Install scan-build toolchain
        run: |
          sudo apt-get update
          sudo apt-get install -y clang-tools cmake ninja-build pkg-config git build-essential
      - name: Run scan-build
        run: |
          tools/scan_build.sh --strict
      - name: Upload scan-build output
        if: always()
        uses: actions/upload-artifact@v6.0.0
        with:
          name: scan-build-report
          path: |
            .scan-build.local.out
            .scan-build.local
          include-hidden-files: true
          retention-days: 7

  semgrep:
    name: semgrep
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v6.0.2
      - name: Set up Python
        uses: actions/setup-python@v6.0.0
        with:
          python-version: "3.x"
      - name: Install Semgrep
        run: python -m pip install --upgrade semgrep
      - name: Run Semgrep
        run: tools/semgrep.sh --strict
      - name: Upload Semgrep output
        if: always()
        uses: actions/upload-artifact@v6.0.0
        with:
          name: semgrep-report
          path: .semgrep.local.out
          include-hidden-files: true
          retention-days: 7

  update-aur:
    name: Update AUR package
    needs: [format-check, clang-tidy, cppcheck, scan-build, semgrep, build-test, sanitize-linux]
    runs-on: ubuntu-latest
    # Only run on upstream pushes; steps guard on AUR key presence
    if: github.repository == 'arancormonk/mbelib-neo' && github.event_name != 'pull_request'
    steps:
      - name: Check AUR SSH key availability
        id: aur_key
        env:
          AUR_SSH_PRIVATE_KEY: ${{ secrets.AUR_SSH_PRIVATE_KEY }}
        run: |
          if [ -z "$AUR_SSH_PRIVATE_KEY" ]; then
            echo "has_key=false" >> "$GITHUB_OUTPUT"
            echo "AUR_SSH_PRIVATE_KEY is not set; skipping AUR update steps."
          else
            echo "has_key=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout repository
        if: steps.aur_key.outputs.has_key == 'true'
        uses: actions/checkout@v6.0.2
        with:
          fetch-depth: 0

      - name: Setup SSH for AUR
        if: steps.aur_key.outputs.has_key == 'true'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.AUR_SSH_PRIVATE_KEY }}" > ~/.ssh/aur
          chmod 600 ~/.ssh/aur
          ssh-keyscan -t ed25519 aur.archlinux.org >> ~/.ssh/known_hosts

      - name: Clone AUR package
        if: steps.aur_key.outputs.has_key == 'true'
        run: |
          GIT_SSH_COMMAND="ssh -i ~/.ssh/aur" git clone ssh://aur@aur.archlinux.org/mbelib-neo-git.git aur-package

      - name: Compute new pkgver
        id: pkgver
        if: steps.aur_key.outputs.has_key == 'true'
        run: |
          cd "$GITHUB_WORKSPACE"
          commit_count=$(git rev-list --count HEAD)
          commit_hash=$(git rev-parse --short=7 HEAD)
          new_pkgver="r${commit_count}.${commit_hash}"
          echo "pkgver=$new_pkgver" >> "$GITHUB_OUTPUT"
          echo "Computed pkgver: $new_pkgver"

      - name: Check if update needed
        id: check
        if: steps.aur_key.outputs.has_key == 'true'
        run: |
          cd aur-package
          # Handle PKGBUILDs with or without leading whitespace
          current_pkgver=$(grep -E '^\s*pkgver=' PKGBUILD | sed 's/.*pkgver=//')
          echo "Current pkgver: $current_pkgver"
          echo "New pkgver: ${{ steps.pkgver.outputs.pkgver }}"
          if [ "$current_pkgver" = "${{ steps.pkgver.outputs.pkgver }}" ]; then
            echo "needs_update=false" >> "$GITHUB_OUTPUT"
            echo "No update needed"
          else
            echo "needs_update=true" >> "$GITHUB_OUTPUT"
            echo "Update needed"
          fi

      - name: Update PKGBUILD
        if: steps.aur_key.outputs.has_key == 'true' && steps.check.outputs.needs_update == 'true'
        run: |
          cd aur-package
          # Handle PKGBUILDs with or without leading whitespace
          sed -i "s/^\(\s*\)pkgver=.*/\1pkgver=${{ steps.pkgver.outputs.pkgver }}/" PKGBUILD
          # Reset pkgrel to 1 for new upstream version
          sed -i "s/^\(\s*\)pkgrel=.*/\1pkgrel=1/" PKGBUILD

      - name: Update .SRCINFO
        if: steps.aur_key.outputs.has_key == 'true' && steps.check.outputs.needs_update == 'true'
        run: |
          cd aur-package
          # Update pkgver in .SRCINFO (lightweight approach)
          sed -i "s/^\(\s*\)pkgver = .*/\1pkgver = ${{ steps.pkgver.outputs.pkgver }}/" .SRCINFO
          # Reset pkgrel to 1
          sed -i "s/^\(\s*\)pkgrel = .*/\1pkgrel = 1/" .SRCINFO
          # Update source line version reference if present
          sed -i "s/mbelib-neo-git-r[0-9]*\.[a-f0-9]*/mbelib-neo-git-${{ steps.pkgver.outputs.pkgver }}/" .SRCINFO

      - name: Commit and push to AUR
        if: steps.aur_key.outputs.has_key == 'true' && steps.check.outputs.needs_update == 'true'
        run: |
          cd aur-package
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add PKGBUILD .SRCINFO
          git commit -m "Update to ${{ steps.pkgver.outputs.pkgver }}"
          GIT_SSH_COMMAND="ssh -i ~/.ssh/aur" git push origin master

  install-and-consume:
    needs: [format-check, clang-tidy, cppcheck, scan-build, semgrep]
    name: install + consume (pkg-config/CMake)
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
    steps:
      - uses: actions/checkout@v6.0.2
      - name: Ensure pkg-config is available (Linux)
        if: runner.os == 'Linux'
        run: sudo apt-get update && sudo apt-get install -y pkg-config
      - name: Ensure pkg-config is available (macOS)
        if: runner.os == 'macOS'
        run: brew update && brew install pkg-config
      - name: Configure (dev-release preset)
        run: cmake --preset dev-release
      - name: Build (dev-release preset)
        run: cmake --build --preset dev-release --parallel
      - name: Install
        run: cmake --install build/dev-release --prefix "$RUNNER_TEMP/mbe-install"
      - name: Test pkg-config consumer
        env:
          PKG_CONFIG_PATH: ${{ runner.temp }}/mbe-install/lib/pkgconfig:${{ env.PKG_CONFIG_PATH }}
        run: |
          cat > consumer.c << 'EOF'
          #include <stdio.h>
          #include <mbelib-neo/mbelib.h>
          int main(void) {
            char ver[32] = {0};
            mbe_printVersion(ver);
            printf("version: %s\n", ver);
            return ver[0] ? 0 : 1;
          }
          EOF
          cc consumer.c $(pkg-config --cflags --libs libmbe-neo) -Wl,-rpath,${RUNNER_TEMP}/mbe-install/lib -o consumer
          ./consumer
      - name: Test CMake package consumer
        run: |
          mkdir -p demo && cd demo
          cat > CMakeLists.txt << 'EOF'
          cmake_minimum_required(VERSION 3.20)
          project(consumer C)
          find_package(mbe-neo CONFIG REQUIRED)
          add_executable(consumer consumer.c)
          target_link_libraries(consumer PRIVATE mbe_neo::mbe_shared)
          EOF
          cat > consumer.c << 'EOF'
          #include <stdio.h>
          #include <mbelib-neo/mbelib.h>
          int main(void) {
            char ver[32] = {0};
            mbe_printVersion(ver);
            printf("version: %s\n", ver);
            return ver[0] ? 0 : 1;
          }
          EOF
          cmake -S . -B build -DCMAKE_PREFIX_PATH="$RUNNER_TEMP/mbe-install" -DCMAKE_BUILD_RPATH="$RUNNER_TEMP/mbe-install/lib"
          cmake --build build --parallel
          ./build/consumer

  install-and-consume-win:
    needs: [format-check, clang-tidy, cppcheck, scan-build, semgrep]
    name: install + consume (CMake, Windows)
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v6.0.2
      - name: Configure (dev-release preset)
        run: cmake --preset dev-release
      - name: Build (dev-release preset)
        run: cmake --build --preset dev-release --parallel
      - name: Install
        run: cmake --install build/dev-release --config Release --prefix "$env:RUNNER_TEMP\\mbe-install"
      - name: Test CMake package consumer (static link)
        shell: bash
        run: |
          mkdir -p demo && cd demo
          cat > CMakeLists.txt << 'EOF'
          cmake_minimum_required(VERSION 3.20)
          project(consumer C)
          find_package(mbe-neo CONFIG REQUIRED)
          add_executable(consumer consumer.c)
          # Link static to avoid DLL path concerns in CI
          target_link_libraries(consumer PRIVATE mbe_neo::mbe_static)
          EOF
          cat > consumer.c << 'EOF'
          #include <stdio.h>
          #include <mbelib-neo/mbelib.h>
          int main(void) {
            char ver[32] = {0};
            mbe_printVersion(ver);
            printf("version: %s\n", ver);
            return ver[0] ? 0 : 1;
          }
          EOF
          cmake -S . -B build -DCMAKE_PREFIX_PATH="$RUNNER_TEMP/mbe-install"
          cmake --build build --config Release --parallel
          ./build/Release/consumer.exe
