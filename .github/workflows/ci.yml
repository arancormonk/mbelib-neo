name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build-test:
    needs: [format-check, clang-tidy]
    name: ${{ matrix.os }} • preset=${{ matrix.preset }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        preset: [dev-debug, dev-release, notones-debug]
    steps:
      - uses: actions/checkout@v5.0.0
      - name: Configure (${{ matrix.preset }})
        run: cmake --preset ${{ matrix.preset }}
      - name: Build (${{ matrix.preset }})
        run: cmake --build --preset ${{ matrix.preset }} --parallel
      - name: Test (${{ matrix.preset }})
        run: ctest --preset ${{ matrix.preset }} -V

  sanitize-linux:
    needs: [format-check, clang-tidy]
    name: linux • Debug • sanitizers
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5.0.0
      - name: Configure (asan-ubsan-debug)
        run: cmake --preset asan-ubsan-debug
      - name: Build (asan-ubsan-debug)
        run: cmake --build --preset asan-ubsan-debug --parallel
      - name: Test (asan-ubsan-debug)
        env:
          ASAN_OPTIONS: detect_leaks=1:halt_on_error=1
          UBSAN_OPTIONS: print_stacktrace=1:halt_on_error=1
        run: ctest --preset asan-ubsan-debug -V

  format-check:
    name: clang-format
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5.0.0
      - name: Install clang-format
        run: sudo apt-get update && sudo apt-get install -y clang-format
      - name: Check formatting
        run: |
          files=$(git ls-files '*.c' '*.h' ':!:build/**')
          if [ -z "$files" ]; then echo "No C/C headers to check"; exit 0; fi
          clang-format --version
          # Prefer dry-run Werror if supported; fallback to diff
          if clang-format -n --Werror $files 2>/dev/null; then
            echo "Formatting OK (clang-format -n --Werror)"
          else
            echo "clang-format -n --Werror unsupported or failed; using diff"
            diff -u <(cat $files) <(clang-format $files) || (echo "Run tools/format.sh" && exit 1)
          fi

  clang-tidy:
    name: clang-tidy
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5.0.0
      - name: Install clang-tidy (latest)
        run: sudo apt-get update && sudo apt-get install -y clang-tidy ripgrep
      - name: Configure (dev-debug preset)
        run: cmake --preset dev-debug
      - name: Run clang-tidy
        run: |
          # Analyze both sources and headers; headers are also checked via header-filter from TUs
          files=$(git ls-files '*.c' '*.h' ':!:build/**')
          if [ -z "$files" ]; then echo "No C files to analyze"; exit 0; fi
          echo "Analyzing: $files"
          # Run clang-tidy using project config
          clang-tidy -p build/dev-debug $files 2>&1 | tee clang-tidy.log || true
          # Fail the job if any analyzer/bugprone diagnostics appear
          if rg -n "\[(clang-analyzer|bugprone).*\]$" clang-tidy.log; then
            echo "clang-tidy found analyzer/bugprone issues (treated as errors)." >&2
            exit 1
          fi
          echo "clang-tidy clean for analyzer/bugprone checks."

  install-and-consume:
    needs: [format-check, clang-tidy]
    name: install + consume (pkg-config/CMake)
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
    steps:
      - uses: actions/checkout@v5.0.0
      - name: Ensure pkg-config is available (Linux)
        if: runner.os == 'Linux'
        run: sudo apt-get update && sudo apt-get install -y pkg-config
      - name: Ensure pkg-config is available (macOS)
        if: runner.os == 'macOS'
        run: brew update && brew install pkg-config
      - name: Configure (dev-release preset)
        run: cmake --preset dev-release
      - name: Build (dev-release preset)
        run: cmake --build --preset dev-release --parallel
      - name: Install
        run: cmake --install build/dev-release --prefix "$RUNNER_TEMP/mbe-install"
      - name: Test pkg-config consumer
        env:
          PKG_CONFIG_PATH: ${{ runner.temp }}/mbe-install/lib/pkgconfig:${{ env.PKG_CONFIG_PATH }}
        run: |
          cat > consumer.c << 'EOF'
          #include <stdio.h>
          #include <mbelib-neo/mbelib.h>
          int main(void) {
            char ver[32] = {0};
            mbe_printVersion(ver);
            printf("version: %s\n", ver);
            return ver[0] ? 0 : 1;
          }
          EOF
          cc consumer.c $(pkg-config --cflags --libs libmbe-neo) -Wl,-rpath,${RUNNER_TEMP}/mbe-install/lib -o consumer
          ./consumer
      - name: Test CMake package consumer
        run: |
          mkdir -p demo && cd demo
          cat > CMakeLists.txt << 'EOF'
          cmake_minimum_required(VERSION 3.20)
          project(consumer C)
          find_package(mbe-neo CONFIG REQUIRED)
          add_executable(consumer consumer.c)
          target_link_libraries(consumer PRIVATE mbe_neo::mbe_shared)
          EOF
          cat > consumer.c << 'EOF'
          #include <stdio.h>
          #include <mbelib-neo/mbelib.h>
          int main(void) {
            char ver[32] = {0};
            mbe_printVersion(ver);
            printf("version: %s\n", ver);
            return ver[0] ? 0 : 1;
          }
          EOF
          cmake -S . -B build -DCMAKE_PREFIX_PATH="$RUNNER_TEMP/mbe-install" -DCMAKE_BUILD_RPATH="$RUNNER_TEMP/mbe-install/lib"
          cmake --build build --parallel
          ./build/consumer

  install-and-consume-win:
    needs: [format-check, clang-tidy]
    name: install + consume (CMake, Windows)
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v5.0.0
      - name: Configure (dev-release preset)
        run: cmake --preset dev-release
      - name: Build (dev-release preset)
        run: cmake --build --preset dev-release --parallel
      - name: Install
        run: cmake --install build/dev-release --config Release --prefix "$env:RUNNER_TEMP\\mbe-install"
      - name: Test CMake package consumer (static link)
        shell: bash
        run: |
          mkdir -p demo && cd demo
          cat > CMakeLists.txt << 'EOF'
          cmake_minimum_required(VERSION 3.20)
          project(consumer C)
          find_package(mbe-neo CONFIG REQUIRED)
          add_executable(consumer consumer.c)
          # Link static to avoid DLL path concerns in CI
          target_link_libraries(consumer PRIVATE mbe_neo::mbe_static)
          EOF
          cat > consumer.c << 'EOF'
          #include <stdio.h>
          #include <mbelib-neo/mbelib.h>
          int main(void) {
            char ver[32] = {0};
            mbe_printVersion(ver);
            printf("version: %s\n", ver);
            return ver[0] ? 0 : 1;
          }
          EOF
          cmake -S . -B build -DCMAKE_PREFIX_PATH="$RUNNER_TEMP/mbe-install"
          cmake --build build --config Release --parallel
          ./build/Release/consumer.exe
